# Generated by Django 5.1.5 on 2025-09-19 04:47

from django.db import migrations


def extract_provided_cho_for_migration(rdf_data):
    """Helper function for RMA object_number extraction"""
    if not rdf_data:
        return None

    provided_cho = rdf_data.get("ore:Aggregation", {}).get("edm:aggregatedCHO", {}).get(
        "edm:ProvidedCHO"
    ) or rdf_data.get("edm:ProvidedCHO")

    return provided_cho


def populate_object_numbers(apps, schema_editor):
    """Populate object_number field with museum-specific extraction logic"""
    MetaDataRaw = apps.get_model('etl', 'MetaDataRaw')

    total_records = MetaDataRaw.objects.count()
    print(f"Processing {total_records} MetaDataRaw records...")

    # Process in batches for better performance
    batch_size = 1000
    processed = 0
    deleted = 0
    to_update = []
    to_delete = []

    for record in MetaDataRaw.objects.all().iterator(chunk_size=batch_size):
        object_number = None

        try:
            if record.museum_slug == 'smk':
                object_number = record.raw_json.get("object_number")

            elif record.museum_slug == 'cma':
                object_number = record.raw_json.get("accession_number")

            elif record.museum_slug == 'met':
                object_number = record.raw_json.get("accessionNumber")

            elif record.museum_slug == 'rma':
                # Complex nested extraction like transformer
                metadata = record.raw_json.get("metadata", {})
                rdf = metadata.get("rdf:RDF", {})
                provided_cho = extract_provided_cho_for_migration(rdf)
                object_number = provided_cho.get("dc:identifier") if provided_cho else None

        except Exception as e:
            print(f"Error extracting object_number for {record.museum_slug}:{record.museum_object_id}: {e}")
            object_number = None

        # Queue records for batch operations
        if not object_number or not isinstance(object_number, str) or not object_number.strip():
            to_delete.append(record.id)
            deleted += 1
        else:
            record.object_number = object_number.strip()
            to_update.append(record)
            processed += 1

        # Process batches
        if len(to_update) >= batch_size:
            MetaDataRaw.objects.bulk_update(to_update, ['object_number'])
            print(f"Updated batch: {processed} records processed so far...")
            to_update = []

        if len(to_delete) >= batch_size:
            MetaDataRaw.objects.filter(id__in=to_delete).delete()
            print(f"Deleted batch: {deleted} records deleted so far...")
            to_delete = []

    # Process remaining records
    if to_update:
        MetaDataRaw.objects.bulk_update(to_update, ['object_number'])
    if to_delete:
        MetaDataRaw.objects.filter(id__in=to_delete).delete()

    print(f"Migration complete: {processed} records updated, {deleted} records deleted")


def reverse_populate_object_numbers(apps, schema_editor):
    """Reverse migration: clear object_number field"""
    MetaDataRaw = apps.get_model('etl', 'MetaDataRaw')
    MetaDataRaw.objects.all().update(object_number=None)


class Migration(migrations.Migration):

    dependencies = [
        ('etl', '0022_metadataraw_object_number_alter_metadataraw_raw_hash'),
    ]

    operations = [
        migrations.RunPython(
            populate_object_numbers,
            reverse_populate_object_numbers,
        ),
    ]
